
## 板书

- nodejs:
    - 1、什么是事件循环?
        - 事件循环是nodejs异步编程的核心。nodejs采用了单线程的处理机制，但是底层通过libuv实现多线程，将请求分发给不同的工作线程异步执行，并将执行结果的回调放入事件循环的事件队列中，等待执行。这样就以异步的方式处理了大量的并发连接。
        - 看过扑灵大神的一次演讲中讲的： 事件循环通俗来讲就是一个while(true){}死循环，按照事件循环的执行阶段依次执行任务队列中的任务
    - 2、ES Modules和CommonJs的区别（模块导入、导出的区别；加载机制的区别）
        - CommonJs是通过module.exports、require进行动态导入导出的,模块加载会经历：路径分析、文件定位、编译执行的过程，采用同步加载机制，并且会有cache缓存。运行时加载，require同步加载 ，输出的是值的拷贝，变量会被缓存。
        - ES Modules是通过export、import静态声明进行导入导出的,在编译时解析模块依赖关系，从而提高性能。支持异步加载，没有缓存，每次都会重新加载。
        - ES Module编译时加载，import异步加载，输出的是值的引用，支持死代码检查和和排除，方便我们使用静态分析工具检测哪些模块未被使用。如果需要使用ES6 Module规范写代码只需要在package.json中添加"type":"module"。并且在nodejs v14版本之后默认的规范是ES Module。社区也逐渐想找个靠拢。
    - 3、nodejs单线程如何高效的解决大量请求的？
        - nodejs接收到请求后将请求进行分发给工作线程异步完成，因此不会堵塞程序，也实现了处理大量IO请求的能力
    - 4、fs.readFile()和fs.createReadStream()的区别
        - fs.readFile()方法读取的文件会全部存到内存中，增加nodejs内存负荷，并且需要等到全部读取完成给你之后才有响应。
        - fs.createReadStream()方法读取文件是以流的方式读取文件，减轻了内存的压力，并且传输速度快。
    - 5、stream中的pipe和pipeline的区别
        - pipe支持数据从流的一端到另一段的传输，多个传输需要串行执行
        - pipeline支持同时并发执行多条流传输，效率高。例如多路下载就是这个原理
    - 6、nodejs如何管理项目进程的？nodejs如何充分利用多核cpu？
        - 管理项目进程采用pm2模块，可以实现单线程单进程下cpu利用率不足的情况。pm2可以开启多个进程，充分利用多核的优势。pm2的mode有两种模式，第一种fork模式，实现单线程多进程；第二种cluster模式，实现多线程多进程模式。常用的还是第一种fork模式，避免多线程场景下数据安全问题（其实就像是回归java这种多线程语言了一样，需要考虑线程资源的竞争）
    - 7、Buffer的应用场景和它的分配机制
        - Buffer是nodejs的缓冲模块，主要实现将数据转为二进制流便于传输。采用的slab机制进行预先申请、事后分配的动态管理机制。
    - 8、怎么理解nodejs的异步
        - 非阻塞 I/O：Node.js 的异步模型基于事件驱动和非阻塞 I/O。这意味着当 Node.js 执行 I/O 操作（如读取文件、数据库操作、网络请求等）时，它不会等待操作完成，而是继续执行后续代码。一旦 I/O 操作完成，相应的回调函数会被加入到事件队列中。
        - 事件循环：Node.js 使用事件循环来处理异步事件。事件循环是一个运行在单线程中的机制，它不断地检查事件队列，并处理队列中的事件。当 I/O 操作完成时，相关的回调函数会被加入到事件队列，事件循环会适时地执行这些回调函数。
        - 回调函数：在 Node.js 中，异步操作通常通过回调函数来处理。当异步操作完成时，Node.js 会调用相应的回调函数。由于回调函数可能会被延迟执行，因此开发者需要特别注意回调函数中的逻辑，以避免出现回调地狱（Callback Hell）。
        - Promises 和 async/await：为了解决回调地狱问题，Node.js 引入了 Promises 和 async/await 语法。Promises 是一种代表异步操作最终完成或失败的对象。async/await 则是基于 Promises 的更高级的语法糖，它允许开发者以同步的方式编写异步代码。
        - 错误处理：在异步编程中，错误处理非常重要。Node.js 中的异步函数通常会接受一个额外的回调函数作为参数，用于处理错误。Promises 也有自己的错误处理机制，即通过 .catch() 方法捕获错误。
        - 性能优势：由于 Node.js 的异步模型可以在等待 I/O 操作完成时继续执行其他任务，因此它可以在单线程中高效地处理大量并发的 I/O 请求，从而提高了性能和资源利用率。
        - 单线程模型：尽管 Node.js 的异步模型运行在单线程中，但它通过事件循环和非阻塞 I/O 避免了传统多线程编程中的竞态条件和锁的问题。
        - Node.js 核心模块的异步实现：许多 Node.js 的核心模块，如 fs（文件系统）、http（网络通信）等，都是基于异步模型实现的。这意味着使用这些模块进行 I/O 操作时，可以充分利用 Node.js 的异步性能优势。
    - 9、nodejs都有哪些加密模块
        - Crypto： 实现AES、DES、MD5等
    - 10、express和koa的区别？
      - 处理方式上： express使用普通的回调函数，一种线性的逻辑，在同一个线程上完成所有的HTTP请求。回调方式不友好，错误没法捕捉，需要一层一层往外传； koa采用的洋葱模型，核心是基于koa-compose实现，每一个中间件执行会通过next()方法到下一个中间件。
- javascript：
    - 1、var、let、const区别？
        - var: 用于声明变量，可以多次声明，存在变量提升。
        - let: 用于变量的声明，不能重复声明，使用前必须先声明，存在暂时性死区，具有局部作用域的能力
        - const: 常用于不变的量的声明，声明的时候必须赋值，基本类型的数据不能被改变，引用类型的不能改变其引用
    - 2、原型链是什么？
        - 原型链是原型查找的一个关系描述。每个函数都有一个prototype属性，如果当他有一个实例对象的时候，当实例对象需要访问某个属性的时候，会在当前实例对象的上查找，当找不到的时候就会查找实例对象的原型（__proto__）上是否拥有，并且实例对象的原型是指向原对象的原型对象。如果原对象的原型对象还没有的话就继续查找原对象原型对象的原型（__proto__），直至找到，最终要么找到，要么找到Object的原型（__proto__）为null。
        - 就这样一层一层查找原型的关系，称为原型链
    - 3、闭包
        - 指一个函数有权访问另一个函数内部变量的函数（重点：它是函数）
        ```javascript
          let name = "上海"
          function A(){
              let name = "北京"
              function B(){
                  console.log(name)
              }
              return B
          }
          A() // 北京
      ```
      - 闭包可以避免全局变量的污染。本质是一个函数拥有另一个函数内部变量的引用。闭包可以临时暂存变量的值：
      ```javascript
          let count = 0
          for(let i = 0; i < 10; i++) {
              count++
          }
          console.log(count) // 10
      ```
      - 过多的闭包会导致内存泄露，google引擎V8采用标记清除的方式进行垃圾回收闭包变量
    - 4、普通函数和箭头函数的this的指向区别？
        - 普通函数：谁调用我，我指向谁
        - 箭头函数：指向当前上下文
    - 5、继承的几种方式？
        - 原型链继承：继承的属性变量共享内存
          ```javascript
            function Parent(){
                this.name = 'zhansan'
                this.play = [1,2,3]
            }
            function Child(){
                this.type = 'child'
            }
            Child.prototype = new Parent()
          ```
        - 构造函数继承（借用call）
        - 组合继承（原型链继承 + 构造函数继承）
        - 原型式继承（使用Object.create()）
        - 寄生式继承
        - 寄生组合式继承
        - ES6 extends
    - 6、Promise手写
        - 定义好三种状态pending、fulfilled、rejected。通过状态机控制pending =》fulfilled；pending =》rejected
    - 7、深浅拷贝手写
        - 浅拷贝：声明一个对象，通过forin遍历传进来的arr，将每个值赋值给新对象
        - 深拷贝：声明一个对象，通过forin遍历传进来的arr，判断值为对象递归调用，不为对象直接拷贝
    - 8、typeof和instanceof的区别
        - typeof: 用于判断基本数据类型，除null外
        - instanceof：通过原型判断当前对象是否为前一个对象的实例
    - 9、javascript的数据类型有哪些？
        - String、Number、Boolean、Null、Undefined、Symbol、BigInt、Object
    - 10、手写instanceof
        ```javascript
            function myInstanceOf(left, right){
                if(typeof left !== 'object' || typeof left === null) return false
                let proto = Object.getPrototypeof(left)
                while(true){
                    if(proto === null) return false
                    if(proto === right.prototype) return true
                    proto = Object.getPrototypeof(left)
                }
            }
        ```
    - 11、手写排序算法（冒泡、快速（分而治之）、插入、归并（分而并之））
        
    - 12、实现1-100之间的素数
        
    - 13、javascript异步编程都有哪些？
        - 回调函数
        - Promise
        - Generator
        - async/await
    - 14、Promise.all(), Promise.allSettled(),Promise.any(),Promise.race()。以及他们的应用场景。
        - Promise.all(): 返回全部执行的结果，有一个失败都失败
        - Promise.allSettled(): 返回全部执行结果，返回的都是真实的每个promise的结果，成功还是失败都返回
        - Promise.any(): 只要返回一个成功，都算成功，全部失败才算失败
        - Promise.race(): 谁先返回就作为返回值。例如：对于图片的加载，将图片请求和超时判断放在一起，用于判断图片是否加载成功
    - 15、如何将一个数组扁平化？
        - arr.toString().join(',')
        - 递归
        - 正则
        - reduce迭代
        - 扩展运算符
    - 16、call、apply、bind的区别，new的实现
  
    - 17、写一个sleep函数
        ```javascript
            const sleep = ms => {
                return new Promise(resolve => {
                    setTimeout(function() {
                        resolve('sleep')
                    },ms)
                })
            }
        ```
    - 18、反转一个数组(中间分开，交换彼此位置)
    - 19、如何实现一个console.log()
        - process.stdout.write()
    - 20、CommonJS和ES6 Module的区别？
    - 21、javascript执行的上下文是什么？
      - javascript的执行上下文主要跟js引擎执行的运行环境有关，浏览器环境下，全局上下文为windows，nodejs环境下，全局上下文为global。
      - 函数执行上下文，在每调用一次函数的时候会创建上下文，包括函数，变量，this相关指向。
      - 模块上下文中，模块内的变量和函数都是局部的，不会污染全局变量
    - 22、
- mysql：
    - 1、工作中如何优化mysql？
        - 代码中：使用连接池
        - sql语句中：避免返回冗余字段，尽量使用覆盖索引；优化sql结构；通过explain执行计划查看sql执行是否有索引，扫描的行数，索引的大小，有索引是否走索引；
        - 线上环境：通过修改conf配置文件，开启慢查询日志，并设置慢sql的时间，将线上慢sql输出到对应文件中，分析具体sql
    - 2、mysql是如何实现索引的？
        - mysql实现索引跟它的储存引擎有关系。储存引擎主流的有两个： MyISAM和InnoDB。现在常用InnoDB，采用的B+树储存引擎，非叶子结点不存储数据，只储存数据键值，叶子节点储存数据。默认页大小为16k，当非叶子节点不存储数据的时候就可以存放更多的键值对，相应的树同层级就更大，树就更矮，这样对于我们磁盘IO查询的时候，查询的次数就减少了，查询效率就高了。
        - 叶子结点采用双向链表，使得其支持范围查找，排序查找，分组查找就更简单了
    - 3、mysql的事务的特征和隔离级别
        - 特征：
          - 原子性：使用undo log来实现，如果事务执行过程中出错或者rollback，系统通过redo log来进行数据回滚（redo log是InnoDB引擎特有，记录每一次sql执行的反命令）
          - 隔离性：通过锁以及MVCC多版本并发控制，使事务隔离
          - 一致性：使用redo log来实现，只要redo log日志持久化了，当数据库崩溃的时候可以通过redo log将奔溃的数据恢复。
          - 持久性：通过回滚、恢复、以及并发情况下的隔离性，从而实现数据的一致性
        - 其中其他三种特性都是为了保证数据的一致性而存在的
        - 隔离级别：
          - 读未提交：一个事务读取到另一个事务未提交的数据，常发生在数据更新阶段
          - 读已提交：一个事务提交后才可以被其他事务看到
          - 可重复读；多次读取的数据事务前后保持一致，InnoDB默认隔离级别
          - 可串行化：事务读写会加锁，必须等待上一个事务将锁释放，下一个事务才可以执行
        - 并发事务会引发什么问题？
          - 脏读：一个事务读取到另一个事务未提交的数据
          - 不可重复读（常发生在数据更新）：事务a读取数据的过程中，b事务对数据进行了修改，使得事务a两次读到的数据不一致
          - 幻读（常发生在数据插入和删除）：事务a读取到数据，之后b事务对数据进行了增加和删除，使得事务a再读取到的数据于事务开始读取到的不一致，出现幻觉。
    - 4、如何保证数据的一致性
        - 通过事务的特性来保持。并通过两阶段提交解决redo log和bin log同步磁盘而发生的数据不一致问题
    - 5、哪些情况下，索引会失效
        使用了聚合函数、or、like %xx、全文扫描比索引快、不满足最左匹配原则等
    - 6、数据库数据崩溃，数据怎么恢复
        一般来说mysql有bin log进行全量数据的备份，可以重放bin log文件恢复数据。但是在数据还没有写到bin log之前就崩溃了，只好通过将redo log中还未来得及的数据用来恢复崩溃数据

- redis和mysql关联的问题：
    - 1、redis和mysql数据如何保持一致性？
        - 导致不一致的原因： 一般来说数据库更新，没有及时更新redis
        - 处理方式：
            - 不正确的思维：删除缓存，并同步数据库数据，不管先删除还是后删除，都可能出现数据不一致的问题
            - 正确思维：
              - 1、延迟删除策略：写库前后都进行删除操作，都会存在频繁数据操作。有可能发生数据不一致问题
              - 2、通过订阅mysql的binlog日志，从而同步到redis中
                

- redis:
    - 1、为什么要用redis？业务场景有哪些？
        - redis是为了提高服务性能， 减轻数据库的IO压力，避免数据库被大流量打蹦，引入缓存中间件。热点数据，用户登录信息，一些临时数据。
    - 2、常见数据类型
        - String、List、Hash、Set、SortSet
    - 3、redis的事务
        - 本质是一组命令的集合，保证数据的一致性。
    - 4、如何防止数据丢失？对持久化的了解？
        - redis通过AOF（追加写），
        - RDB（一次快照全量备份）（发送save和bgsave命令让服务器生成rgb）持久化
        - RDB进行数据的全量备份，用于数据崩溃时的全量恢复； AOF追加写，用于恢复RDB丢失的数据。

- 项目技能点
  - 项目中遇到的问题
    - 1、js项目接入ts形式的sdk
    -  2、数据库拒绝连接，因为没有释放连接，导致连接不上。虽然使用了连接池，但是没有设置连接池上限，所用DM数据库默认没有连接池上限限制。所以导致连接满了。
    -  3、事件监听机制总会延迟返回数据，on事件注册不断增加，并没有释放导致连接太多提示‘setMaxListener 10’，导致内存泄露的问题
    -  4、数据库定时全量备份
    -  5、因为前端特殊表情包数据，存到数据库报错了，采用Buffer，并没有修改数据库的编码规格
    -  6、因为require()缓存导致配置没有生效
  - 单点登录怎么实现？
    - 单点登录指的是一处登录，多个系统之间共享这个登录态。用户方面存在一个认证中心，验证一次得到一个ticket，并在有限期内，其他也可以使用这个ticket去验证是否登录，从而避免多次登录。
  - nodejs项目私有化方案的部署：
    - 背景：nodejs项目处于内部网络中，最终需要将项目部署到硬件服务器上，需要处理系统软件兼容(linux（飞腾、申威、麒麟、中标麒麟)，x64、arm64、sw64等相关硬件和软件系统版本问题），并制定部署方案。
    - 问题：nodejs项目底层libuv库虽然支持跨平台运行，但是架不住项目中部分npm包需要依赖于c++环境进行编译，当软件不在目标服务器机器上使用网络进行npm install安装的包的时候，将项目部署到服务器上，大部分会出现包报错的问题。因此需要针对不同的nodejs项目做兼容性处理，解决npm包环境下的编译问题。
    - 解决1：编译npm包：
    - 第一种：
      - 在一个与目标服务器一样的有网络开发环境中npm install（但是公司无这么多不同环境和cpu架构的电脑）。 安装不同环境的虚拟机，但是解决了不了node-gyp平台编译问题。
      - 使用node-gyp重新编译这些npm包（不能够实现，因为node-gyp依赖于python、Make、GCC等工具，它需要根据不同平台进行配置）
      - 使用Docker多架构镜像方案（也称多平台镜像或交叉平台镜像），它能够支持在不同的CPU架构上运行。使用Docker Buildx插件，提供构建多平台镜像的功能。
      - 使用QEMU 用户模式：它是一种网络配置方式，它在 QEMU 进程中实现一个协议栈，这个协议栈可以被视为一个主机与虚拟机之间的 NAT 服务器，它负责将 QEMU 所模拟的系统网络请求转发到外部网卡上面，从而实现网络通信。可以模拟CPU架构，使我们在没有特定硬件的情况下，为不同架构构建和测试镜像。
    - 第二种：
    - 问题2: 避免源码泄露，项目进行打包操作
       - 使用pkg进行打包（好处：在服务器上不用在安装平台指定的nodejs版本，因为pkg已经将运行时打包进去了）， 需要优化项目部分结构。
    - 第三种：为部署流程编写文档，对成员进行部署流程分享，和故障排查讲解
    - 部署方案：（1）、在指定测试服务器下进行对应安装库包关系，保证运行正常。解决npm包编译问题。（2）、针对项目进行pkg打包，打包成指定平台可执行文件。上传到指定服务器进行pm2部署，并编写脚本保证开机自启。
  - nodejs实时通信WebSocket技术封装：
    - 兼容性：由于所使用浏览器不支持socket.io使用，故采用websocket库
    - 连接管理：会话管理，自动重连，数据流式传输
    - 心跳机制：定期发送心跳包，保证连接正常
    - 采用zeromq解决nodejs和c++之间数据通讯问题
  - 日志系统建设：
    - 线上运营问题跟踪排查都只能通过代码和行为日志记录进行排查，效率太低。 因此引入日志系统，针对每一个请求操作都进行记录，便于业务问题的跟踪排查。
    - 对比pino、winston和log4js
  - 双token无感刷新登录
    - access_token、refresh_token。
    - 前端操作：进行接口请求的时候，只需要判断headers中有没有authorization中的token，过期的话自动调用刷新token接口生成新token
    - 后端操作：用户登录设计的时候时候设计返回两个token，一个access_token（设置过期时间短）、refresh_token（过期时间长，主要用于更新token）。
      - 第一次登录之后，根据JWT生成token，并生成两个token，返还给前端。之后如果前端调用刷新token，那么就解析refresh_token获取用于用户信息，并通过获取用户信息，生成新的token用户返回。

